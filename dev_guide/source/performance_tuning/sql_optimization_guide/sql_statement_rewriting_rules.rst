:original_name: dws_04_0452.html

.. _dws_04_0452:

.. _en-us_topic_0000001628950661:

SQL Statement Rewriting Rules
=============================

Based on the database SQL execution mechanism and a large number of practices, summarize finds that: using rules of a certain SQL statement, on the basis of the so that the correct test result, which can improve the SQL execution efficiency. You can comply with these rules to greatly improve service query efficiency.

-  Replacing **UNION** with **UNION ALL**

   **UNION** eliminates duplicate rows while merging two result sets but **UNION ALL** merges the two result sets without deduplication. Therefore, replace **UNION** with **UNION ALL** if you are sure that the two result sets do not contain duplicate rows based on the service logic.

-  **Adding NOT NULL to the join column**

   If there are many **NULL** values in the **JOIN** columns, you can add the filter criterion **IS NOT NULL** to filter data in advance to improve the **JOIN** efficiency.

-  Converting **NOT IN** to **NOT EXISTS**

   **nestloop anti join** must be used to implement **NOT IN**, and **Hash anti join** is required for **NOT EXISTS**. If no **NULL** value exists in the **JOIN** column, **NOT IN** is equivalent to **NOT EXISTS**. Therefore, if you are sure that no **NULL** value exists, you can convert **NOT IN** to **NOT EXISTS** to generate **hash joins** and to improve the query performance.

   As shown in the following figure, the **t2.d2** column does not contain null values (it is set to **NOT NULL**) and **NOT EXISTS** is used for the query.

   ::

      SELECT * FROM t1 WHERE  NOT EXISTS (SELECT * FROM t2 WHERE t1.c1=t2.d2);

   The generated execution plan is as follows:


   .. figure:: /_static/images/en-us_image_0000001233883423.png
      :alt: **Figure 1** **NOT EXISTS** execution plan

      **Figure 1** **NOT EXISTS** execution plan

-  Use **hashagg**.

   If a plan involving groupAgg and SORT operations generated by the **GROUP BY** statement is poor in performance, you can set **work_mem** to a larger value to generate a **hashagg** plan, which does not require sorting and improves the performance.

-  Replace functions with **CASE** statements

   The GaussDB(DWS) performance greatly deteriorates if a large number of functions are called. In this case, you can modify the pushdown functions to **CASE** statements.

-  **Do not use functions or expressions for indexes.**

   Using functions or expressions for indexes stops indexing. Instead, it enables scanning on the full table.

-  Do not use **!=** or **<>** operators, **NULL**, **OR**, or implicit parameter conversion in **WHERE** clauses.

-  **Split complex SQL statements.**

   You can split an SQL statement into several ones and save the execution result to a temporary table if the SQL statement is too complex to be tuned using the solutions above, including but not limited to the following scenarios:

   -  The same subquery is involved in multiple SQL statements of a task and the subquery contains large amounts of data.
   -  Incorrect **Plan cost** causes a small hash bucket of subquery. For example, the actual number of rows is 10 million, but only 1000 rows are in hash bucket.
   -  Functions such as **substr** and **to_number** cause incorrect measures for subqueries containing large amounts of data.
   -  **BROADCAST** subqueries are performed on large tables in multi-DN environment.
