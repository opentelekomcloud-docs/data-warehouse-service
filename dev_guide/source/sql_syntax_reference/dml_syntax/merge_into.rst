:original_name: dws_06_0235.html

.. _dws_06_0235:

MERGE INTO
==========

Function
--------

The **MERGE INTO** statement is used to conditionally match data in a target table with that in a source table. If data matches, **UPDATE** is executed on the target table; if data does not match, **INSERT** is executed. You can use this syntax to run **UPDATE** and **INSERT** at a time for convenience.

Precautions
-----------

-  To run **MERGE INTO**, you must have the UPDATE and INSERT permissions for the target table, as well as the SELECT permission for the source table.
-  **PREPARE** is not supported.
-  **MERGE INTO** cannot be executed during redistribution.
-  **MERGE INTO** cannot be executed for target tables that contain triggers.
-  When executing **MERGE INTO** for the round-robin table, you are advised to disable the GUC parameter **allow_concurrent_tuple_update**. Otherwise, some **MERGE INTO** statements are not supported.

Syntax
------

::

   MERGE [/*+ plan_hint */] INTO table_name [ partition_clause ] [ [ AS ] alias ]
   USING { { table_name | view_name } | subquery } [ partition_clause ] [ [ AS ] alias ]
   ON ( condition )
   [
     WHEN MATCHED THEN
     UPDATE SET { column_name = { expression | DEFAULT } |
             ( column_name [, ...] ) = ( { expression | DEFAULT } [, ...] ) } [, ...]
     [ WHERE condition ]
   ]
   [
     WHEN NOT MATCHED THEN
     INSERT { DEFAULT VALUES |
     [ ( column_name [, ...] ) ] VALUES ( { expression | DEFAULT } [, ...] ) [, ...] [ WHERE condition ] }
   ];

   where partition_clause can be:
   PARTITION ( partition_name ) | PARTITION FOR ( partition_key_value [, ...] )

Parameter Description
---------------------

-  **plan_hint** clause

   Following the keyword in the ``/*+ */`` format, hints are used to optimize the plan generated by a specified statement block. For details, see "Hint-based Tuning" in the *Data Warehouse Service (DWS) Developer Guide*.

-  **INTO** clause

   Specifies the target table that is being updated or has data being inserted.

   -  **table_name**

      Specifies the name of the target table.

   -  **partition_clause**

      Specifies a partition in the target table. This clause is supported by clusters of version 8.2.1.220 or later.

      Partitions can be specified only if the target table is a partitioned one.

      The specified partition name must already exist in the target table or the partition specified by the partition key already exists.

   -  **alias**

      Specifies the alias of the target table.

      Value range: a string. It must comply with the naming convention.

-  **USING** clause

   Specifies the source table, which can be a table, view, or subquery.

   -  **partition_clause**

      Specifies a partition in the source table. This clause is supported by clusters of version 8.2.1.220 or later.

      Partitions can be specified only if the source table is a partitioned one. Partitions cannot be specified for views or subqueries.

      The specified partition name must already exist in the source table or the partition specified by the partition key already exists.

-  **ON** clause

   Specifies the condition used to match data between the source and target tables. Columns in the condition cannot be updated. The **ON** association condition can be **ctid**, **xc_node_id**, or **tableoid**.

-  **WHEN MATCHED** clause

   Performs the UPDATE operation if data in the source table matches that in the target table based on the condition.

   Distribution keys cannot be updated. System catalogs and system columns cannot be updated.

   With a partition specified in the target table, if the UPDATE causes the partition keys to change:

   -  If the target table is a column-store table, the error message "The inserted partition key is not mapped to the specified 'partition_name' partition" is displayed.
   -  If the target table is a row-store table:

      -  If ENABLE ROW MOVEMENT is set for the target table, no error will be reported, the updated data will belong to the new partition.
      -  If Disable ROW MOVEMENT is set for the target table, the error message "fail to update partitioned table "table_name" will be displayed.

-  **WHEN NOT MATCHED** clause

   Specifies that the INSERT operation is performed if data in the source table does not match that in the target table based on the condition.

   The **INSERT** clause is not allowed to contain multiple **VALUES**.

   The order of **WHEN MATCHED** and **WHEN NOT MATCHED** clauses can be reversed. One of them can be used by default, but they cannot be both used at one time. Two **WHEN MATCHED** or **WHEN NOT MATCHED** clauses cannot be specified at the same time.

   If a partition in the target table is specified and more data beyond the scope of the partition is inserted, the error message "The inserted partition key is not mapped to the specified 'partition_name' partition" will be displayed.

-  **DEFAULT**

   Specifies the default value of a column.

   It will be **NULL** if no specific default value has been assigned to it.

-  **WHERE condition**

   Specifies the conditions for the **UPDATE** and **INSERT** clauses. The two clauses will be executed only when the conditions are met. The default value can be used. System columns cannot be referenced in **WHERE condition**.

Examples
--------

Create the target table **products** and source table **newproducts**, and insert data to them.

::

   CREATE TABLE products
   (
   product_id INTEGER,
   product_name VARCHAR2(60),
   category VARCHAR2(60)
   );

   INSERT INTO products VALUES (1501, 'vivitar 35mm', 'electrncs');
   INSERT INTO products VALUES (1502, 'olympus is50', 'electrncs');
   INSERT INTO products VALUES (1600, 'play gym', 'toys');
   INSERT INTO products VALUES (1601, 'lamaze', 'toys');
   INSERT INTO products VALUES (1666, 'harry potter', 'dvd');

   CREATE TABLE newproducts
   (
   product_id INTEGER,
   product_name VARCHAR2(60),
   category VARCHAR2(60)
   );

   INSERT INTO newproducts VALUES (1502, 'olympus camera', 'electrncs');
   INSERT INTO newproducts VALUES (1601, 'lamaze', 'toys');
   INSERT INTO newproducts VALUES (1666, 'harry potter', 'toys');
   INSERT INTO newproducts VALUES (1700, 'wait interface', 'books');

Run **MERGE INTO**.

::

   MERGE INTO products p
   USING newproducts np
   ON (p.product_id = np.product_id)
   WHEN MATCHED THEN
     UPDATE SET p.product_name = np.product_name, p.category = np.category WHERE p.product_name != 'play gym'
   WHEN NOT MATCHED THEN
     INSERT VALUES (np.product_id, np.product_name, np.category) WHERE np.category = 'books';

Query updates.

::

   SELECT * FROM products ORDER BY product_id;
    product_id |  product_name  | category
   ------------+----------------+-----------
          1501 | vivitar 35mm   | electrncs
          1502 | olympus camera | electrncs
          1600 | play gym       | toys
          1601 | lamaze         | toys
          1666 | harry potter   | toys
          1700 | wait interface | books
   (6 rows)

Delete a table.

::

   DROP TABLE products;
   DROP TABLE newproducts;
